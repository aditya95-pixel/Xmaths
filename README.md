# Project Documentation

## Why did we use MongoDB for Xmaths?

1. **Flexible Schema** : Future features might introduce new types of messages.  With MongoDB, we can easily add new fields to our messages array or even new top-level fields to Chat documents without requiring complex migrations that would be necessary in a relational database.

2. **Document Model (JSON-like Documents)** : Embedded Documents: The messages array within the Chat document is a perfect example of MongoDB's document model strength. All the messages for a specific chat are stored together in a single document. This reduces the number of queries needed to retrieve a full chat conversation, as you fetch one Chat document and get all its related messages, leading to faster read performance for chat history.

3. **Scalability (Horizontal Scaling)** : We can distribute our data across multiple servers (shards) as our data volume or traffic increases, allowing us to scale out gracefully without needing to upgrade to larger, more expensive single servers. This "scale-out" approach is generally more cost-effective and resilient than "scale-up."(vertical scaling)

4. **Performance for Read-Heavy Workloads**

## Role Of Mongoose in Our Project 

Mongoose is an Object Data Modeling (ODM) library for MongoDB and Node.js. It provides a straightforward, schema-based solution to model our application data, enforcing a structure on the otherwise schemaless MongoDB documents.

## Database Models

### MongoDB User Collection Schema – Xmaths App (Clerk Auth + Webhook)

This document outlines the structure of the `User` collection in the **Xmaths** application. Users are managed via **Clerk**, and user records are synchronized to MongoDB using a **Webhook Handler** in `app/api/clerk/route.js`.

---

#### Webhook Handler

Webhook events handled from Clerk:

- `user.created` → Creates a new user in the MongoDB `User` collection.
- `user.updated` → Updates an existing user record.
- `user.deleted` → Deletes the user from the database.

Webhook route:
```js
// file: app/api/clerk/route.js
const userData={
        _id:data.id,
        email:data.email_addresses[0].email_address,
        name:`${data.first_name} ${data.last_name}`,
        image:data.image_url,
    };
switch (type) {
  case "user.created":
    await User.create(userData);
    break;
  case "user.updated":
    await User.findByIdAndUpdate(data.id, userData);
    break;
  case "user.deleted":
    await User.findByIdAndDelete(data.id);
    break;
}
```

| **Field Name** | **Type** | **Required** | **Description**                                         | **Source from Clerk**                    |
| -------------- | -------- | ------------ | ------------------------------------------------------- | ---------------------------------------- |
| `_id`          | String   |  Yes        | Unique Clerk User ID (used as MongoDB \_id).            | `data.id`                                |
| `email`        | String   |  Yes        | User's primary email address.                           | `data.email_addresses[0].email_address`  |
| `name`         | String   |  Yes        | Full name of the user (first + last).                   | `data.first_name + " " + data.last_name` |
| `image`        | String   |  No         | Profile image URL from Clerk.                           | `data.image_url`                         |
| `createdAt`    | Date     |  Yes        | Auto-generated timestamp when user is added to MongoDB. | Mongoose `timestamps`                    |
| `updatedAt`    | Date     |  Yes        | Auto-updated timestamp when user data changes.          | Mongoose `timestamps`                    |

### Chat Collection Schema 

This document outlines the structure of the **Chat** collection in the MongoDB database. This collection stores individual chat sessions between users and the **Xmaths AI assistant**, including full conversation history.

---

#### Collection: `Chat`

| **Field Name**     | **Type**               | **Required** | **Description**                                                   | **Notes** |
|--------------------|------------------------|--------------|-------------------------------------------------------------------|-----------|
| `_id`              | `ObjectId`             |  Yes       | Unique identifier for the chat session.                          | Auto-generated by MongoDB/Mongoose. |
| `name`             | `String`               |  Yes       | A user-friendly name/title for the chat session.                 | Could be the initial user query, a summary, or a custom name (e.g., *"Linear Algebra: Eigenvalues"*). |
| `messages`         | `Array<Object>`        |  Yes       | Ordered list of messages exchanged in this chat session.         | Embedded subdocuments. Efficient for retrieving full conversation. |
| `messages[].role`  | `String`               |  Yes       | Sender of the message: `"user"` or `"system"`.                | Used to render messages in UI properly. |
| `messages[].content` | `String`             |  Yes       | Text content of the message. Includes queries, responses, LaTeX, etc. | Can include mathematical formulas, code snippets, etc. |
| `messages[].timestamp` | `String`           |  Yes       | Time when the message was created.                               | - |
| `userId`           | `String`               |  Yes       | Reference to the `_id` of the user who owns the chat.            | - |
| `createdAt`        | `Date`                 |  Yes       | When the chat document was created.                              | Managed automatically by Mongoose (`timestamps: true`). |
| `updatedAt`        | `Date`                 |  Yes       | When the chat document was last updated.                         | Updated on each message addition or edit. |

---


## MongoDB Connection Utility with Caching (Mongoose)

This module provides a reliable and optimized way to connect to MongoDB using **Mongoose**, with support for **connection caching** to prevent duplicate connections — especially useful in environments like **Next.js**, **serverless functions**, or apps using **hot-reloading**.

---

###  Why Use This?

Connecting to MongoDB repeatedly in environments like:

- Serverless platforms (e.g., Vercel, AWS Lambda)
- Development environments with hot-reloading (e.g., Next.js)

...can result in **too many open connections**, leading to performance issues or MongoDB errors.

This utility solves the problem by:
- Reusing an already established connection (`conn`)
- Avoiding multiple concurrent connection attempts (`promise`)

---

###  How It Works

```js
// config/db.js
import mongoose from "mongoose";

let cached = global.mongoose || { conn: null, promise: null };

export default async function connectDB() {
    if (cached.conn) {
        return cached.conn;
    }
    if (!cached.promise) {
        cached.promise = mongoose.connect(process.env.MONGODB_URI).then((mongoose) => mongoose);
    }
    try {
        cached.conn = await cached.promise;
    } catch (error) {
        console.error("Error connecting to MongoDB", error);
    }
    return cached.conn;
}

```

## AppContextProvider – Global State Management for Authenticated Chat

This module implements a global context provider for managing **authenticated user sessions**, **chat data**, and **API interactions** in a Clerk-powered Next.js app.

It ensures that:
- User chat sessions are initialized and fetched upon login
- Chat state (chats, selectedChat) is accessible across the app
- Auth tokens are correctly handled when communicating with secured backend endpoints

---

###  Features

-  Automatically fetches or creates chat sessions for the user
-  Global access to chat and user state via React Context
-  Axios-based secure API calls with Bearer tokens
-  User-friendly error reporting via `react-hot-toast`

---


### Code

```js
// context/AppContext.jsx

"use client"; // Indicates this is a Client Component in Next.js

import { useAuth, useUser } from "@clerk/nextjs"; // Clerk for authentication
import axios from "axios"; // For making HTTP requests
import { createContext, useContext, useEffect, useState } from "react"; // React hooks
import toast from "react-hot-toast"; // For displaying notifications

// 1. Create the Context
export const AppContext = createContext();

// 2. Custom Hook to Consume the Context
export const useAppContext = () => {
    return useContext(AppContext);
}

// 3. Context Provider Component
export const AppContextProvider = ({ children }) => {
    // 3.1. Authentication Hooks from Clerk
    const { user } = useUser(); // Provides user object (includes user.id, user.fullName, etc.)
    const { getToken } = useAuth(); // Provides a function to get the authentication token

    // 3.2. State Variables
    const [chats, setChats] = useState([]); // Stores an array of all chat sessions for the current user
    const [selectedChat, setSelectedChat] = useState(null); // Stores the currently active chat session

    // 3.3. createNewChat Function
    const createNewChat = async () => {
        try {
            if (!user) { // Ensure user is logged in before creating a chat
                console.warn("Attempted to create new chat without a logged-in user.");
                return null;
            }
            const token = await getToken(); // Get the authentication token from Clerk
            // Send a POST request to create a new chat on the backend
            await axios.post('/api/chat/create', {}, { headers: { Authorization: Bearer ${token} } });
            fetchUsersChats(); // After creating, refetch all chats to update the UI
        } catch (error) {
            console.error("Error creating new chat:", error); // Log for debugging
            toast.error(error.message); // Display error to the user
        }
    }

    // 3.4. fetchUsersChats Function
    const fetchUsersChats = async () => {
        try {
            // Get the authentication token
            const token = await getToken();
            // Send a GET request to fetch all chats for the current user
            const { data } = await axios.get('/api/chat/get', { headers: { Authorization: Bearer ${token} } });

            if (data.success) { // Check if the API response indicates success
                setChats(data.data); // Update the chats state with fetched data

                if (data.data.length === 0) {
                    // If no chats exist, create a new one automatically
                    await createNewChat();
                    return fetchUsersChats(); // After creating, refetch again to load the new chat
                } else {
                    // Sort chats by updatedAt timestamp (most recent first)
                    data.data.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                    // Set the most recent chat as the selected chat
                    setSelectedChat(data.data[0]);
                }
            } else {
                toast.error(data.message); // Display error message from the API
            }
        } catch (error) {
            console.error("Error fetching user chats:", error); // Log for debugging
            toast.error(error.message); // Display error to the user
        }
    }

    // 3.5. useEffect Hook for Initial Data Fetching
    useEffect(() => {
        if (user) { // Only fetch chats if a user is logged in (Clerk's user object is available)
            fetchUsersChats();
        }
    }, [user]); // Dependency array: re-run this effect when the 'user' object changes

    // 3.6. Context Value
    const value = {
        user,             // The Clerk user object
        chats,            // Array of all user's chat sessions
        setChats,         // Function to update the chats array
        selectedChat,     // The currently active chat session
        setSelectedChat,  // Function to set the active chat session
        fetchUsersChats,  // Function to refetch all user chats
        createNewChat     // Function to create a new chat session
    }

    // 3.7. Provide the Context
    return <AppContext.Provider value={value}>{children}</AppContext.Provider>
}
```

## Explanation for our app/api/chat/create/route.js file.

### Code 

```js
import connectDB from "@/config/db";
import Chat from "@/models/Chat";
import { getAuth } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";
export async function POST(req) {
    try {
        const {userId}=getAuth(req);
        if(!userId){
            return NextResponse.json({success:false,message:"User not authenticated"});
        }
        const chatData={
            userId,
            messages:[],
            name:"New Chat",
        };
        await connectDB();
        await Chat.create(chatData);
        return NextResponse.json({success:true,message:"Chat created"});
    } catch (error) {
        return NextResponse.json({success:false,error:error.message});
    }

}
```

### Purpose
This endpoint allows the frontend to request the creation of a new, empty chat session associated with the currently authenticated user. It's typically called when a user initiates a new conversation or when they have no existing chats.

### How it Works
- Authentication Check: It first uses Clerk's getAuth(req) to extract the userId from the incoming request. If no userId is found (meaning the user is not authenticated), it immediately returns an error response.

- Prepare Chat Data: It constructs a basic chatData object, including:
  1. userId: The ID of the authenticated user.
  2. messages: An empty array, as it's a new chat.
  3. name: A default name "New Chat" (which can be updated later by the user).

- Database Connection: It calls connectDB() to establish or reuse a connection to the MongoDB database.
- Create Chat Document: It then uses the Mongoose Chat.create() method to save the chatData object as a new document in the chats collection in MongoDB.
- Success Response: If the chat document is successfully created, it returns a success response.
- Error Handling: Any errors during the process (e.g., authentication failure, database connection issues, Mongoose validation errors) are caught, and an appropriate error response is returned.

**API Route** : /api/chat/create
- This API route handles the creation of new chat sessions for authenticated users in the Xmaths application.

**File Path** : app/api/chat/create/route.js

**Method** : POST

**Headers** :
- Authorization: Bearer <Clerk_JWT_Token>: A valid JSON Web Token obtained from Clerk on the frontend. This is essential for authenticating the user.

**Body** :
- This endpoint expects an empty request body {}. All necessary information (like userId) is extracted from the authentication token.

**Response** :
This endpoint returns a JSON object with success and message (or error) properties.

## Explanation for our app/api/chat/delete/route.js file.

### Code

```js
import connectDB from "@/config/db";
import Chat from "@/models/Chat";
import { getAuth } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";
export async function POST(req) {
    try {
        const {userId}=getAuth(req);
        const {chatId}=await req.json();
        if(!userId){
            return NextResponse.json({
                success:false,
                message:"User not authenticated"
            });
        }
        await connectDB();
        await Chat.deleteOne({_id:chatId,userId});
        return NextResponse.json({success:true,message:"Chat Deleted"});
    } catch (error) {
        return NextResponse.json({success:false,error:error.message});
    }
}
```

### Purpose
This endpoint allows an authenticated user to delete a specific chat session from their history. It ensures that a user can only delete chats that belong to them.

### How it Works
**Authentication Check** : It retrieves the userId from the incoming request using Clerk's getAuth(req). If no userId is present, it means the user is not authenticated, and an error response is returned immediately.

**Extract Chat ID** : It parses the request body to extract the chatId of the chat session intended for deletion.

**Database Connection** : It establishes or reuses a connection to the MongoDB database via connectDB().

**Delete Chat Document** : It executes a Chat.deleteOne() operation on the MongoDB chats collection. Crucially, it uses a compound query:

  1. _id: chatId: Matches the specific chat document by its unique ID.
  2. userId: This is a critical security measure. It ensures that the document being deleted also belongs to the authenticated userId. This prevents users from deleting other users' chats by      simply guessing chatIds.

**Success Response** : If the deleteOne operation completes (even if no document matched the criteria, the operation itself is considered successful), it returns a success message.

**Error Handling** : Any errors during the process (e.g., authentication failure, database issues, invalid chatId format) are caught, and an error response is returned.

**API Route** : /api/chat/delete
- This API route handles the deletion of existing chat sessions for authenticated users in the Xmaths application.

**File Path**: app/api/chat/delete/route.js

**Method**: POST 

**Headers** :
- Authorization: Bearer <Clerk_JWT_Token>: A valid JSON Web Token obtained from Clerk. Essential for user authentication.

**Content-Type** : application/json: Indicates that the request body is JSON.

**Body** : A JSON object containing the chatId of the chat to be deleted.

**Response** : This endpoint returns a JSON object with success and message (or error) properties.
